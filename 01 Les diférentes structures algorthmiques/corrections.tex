\setcounter{subsection}{1}
\subsection{Variables}
\begin{cor}
Remplir le tableau suivant :\\
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
Identificateur & Contenu & Type \\
\hline
a & 5 & entier\\
\hline
moyenne & 15.2 & flottant \\
\hline
Nom & "Alan" & chaîne de caractères\\
\hline
initiale & 'T' & caractère\\
\hline
fini & Vrai & booléen\\
\hline
\end{tabularx}
\end{cor}

\begin{cor}[Python]
La fonction \texttt{type()} permet de déterminer le type d'une variable. Par exemple, en tapant \texttt{type(a)} dans la console, on obtient la réponse \texttt{int}.\\
Tester le type des 4 autres variables. Que remarquez-vous ?\\
En Python, on ne fait pas la distinction entre caractère et chaîne de caractères. Dans les deux cas ce sont des chaînes de caractères (\texttt{str}). D'ailleurs, on peut aussi bien définir une chaîne de caractère entre guillemets ou entre apostrophe.
\end{cor}

\begin{cor}[Python]
Essayer de deviner le résultat des opérations suivantes écrites en Python.
\begin{multicols}{2}
\begin{lstlisting}
a = 11
b = 2
c = 2.0
prenom = "Ada"
nom = "Lovelace"

d = a + b
e = a + c
f = a * b
g = a * c
h = a ** b
i = a / b
j = a // b
k = a % b
l = prenom + nom
m = b * prenom
n = c * prenom
o = prenom / b
p = prenom // b
\end{lstlisting}

\columnbreak

\noindent
\begin{tabularx}{\linewidth}{|X|X|X|}
\hline
Identificateur & Contenu & Type \\
\hline
d & 13 & entier\\
\hline
e & 13.0 & flottant\\
\hline
f & 22 & entier\\
\hline
g & 22.0 & flottant\\
\hline
h & 121 & entier \\
\hline
i & 5.5 & flottant\\
\hline
j & 5 & entier\\
\hline
k & 1 & entier\\
\hline
l & "AdaLovelace" & chaîne de caractères\\
\hline
m & "AdaAda" & chaîne de caractères\\
\hline
n & \texttt{TypeError} & \texttt{can't multiply sequence by non-int of type 'float'}\\
\hline
o & \texttt{TypeError} & \texttt{unsupported operand type(s) for /: 'str' and 'int'}\\
\hline
p & \texttt{TypeError} &\texttt{unsupported operand type(s) for //: 'str' and 'int'} \\
\hline
\end{tabularx}
\end{multicols}
\end{cor}

\newpage
\begin{cor}
\begin{multicols}{3}
1. Quelles seront les valeurs des variables \texttt{a} et  \texttt{b} après exécution des affectations suivantes ?\\
\begin{algorithm}[H]
$a \leftarrow 2$ \;
$b \leftarrow a-3$ \;
$a \leftarrow 3$ \;
\end{algorithm}
\noindent\texttt{a} contient 3 \\
\texttt{b} contient 1\\

\columnbreak
2. Quelles seront les valeurs des variables \texttt{a}, \texttt{b} et \texttt{c} après exécution des affectations suivantes ?\\
\begin{algorithm}[H]
$a \leftarrow 15$ \;
$b \leftarrow -8$ \;
$c \leftarrow a+b$ \;
$a \leftarrow 6$ \;
$c \leftarrow b-a$ \;
\end{algorithm}
\noindent\texttt{a} contient 6 \\
\texttt{b} contient -8 \\
\texttt{c} contient -14\\

\columnbreak
3. Quelles seront les valeurs des variables \texttt{a} et  \texttt{b} après exécution des affectations suivantes ?\\
\begin{algorithm}[H]
$a \leftarrow 5$ \;
$b \leftarrow 2$ \;
$a \leftarrow b$ \;
$b \leftarrow a$ \;
\end{algorithm}
\noindent\texttt{a} contient 2 \\
\texttt{b} contient 2\\
\end{multicols}
\end{cor}




\begin{cor}
\begin{multicols}{2}
Écrire un algorithme qui permet d'échanger les valeurs des variables \texttt{a} et \texttt{b}.\\
Autrement dit, \texttt{a} vaut 5 et \texttt{b} vaut 2. A la fin de l'algorithme ce sera le contraire.\\

\columnbreak
\begin{algorithm}[H]
$a \leftarrow 5$ \;
$b \leftarrow 2$ \;
$temp \leftarrow a$ \;
$a \leftarrow b$ \;
$b \leftarrow temp$ \;
\end{algorithm}
\end{multicols}
Il est à noter que le langage Python permet d'écrire cet échange rapidement :
\begin{lstlisting}
a = 5
b = 2
a, b = b, a
\end{lstlisting}
C'est ce qu'on appelle une \textbf{pythonnerie}, une spécificité du langage Python. Enfin pour ceux que ça intéresse, Python utilise pour faire cet échange la notion de tuple\footnote{\textit{--Mais Monsieur ! C'est vraiment bizarre comme truc ! Vous dites comment ? Un tuple ?\\ -- Oui, je sais petit scarabée. Nous verrons ça plus tard, dans le détail au chapitre n°7. Il FAUT suivre le plan !}}. 
\end{cor}




\subsection{Structures conditionnelles}
\begin{cor}[Python]
\begin{multicols}{2}
On dispose de deux variables \texttt{nb} qui contient un nombre entier et \texttt{reponse} qui contient un booléen. Votre programme devra affecter la valeur \texttt{True} si \texttt{nb} est pair et \texttt{False} sinon.
\columnbreak
\begin{lstlisting}
nb = 5 #tester d'autres valeurs de nb
if nb%2 == 0 :
	reponse = True
else :
	reponse = False
\end{lstlisting}
\end{multicols}
\noindent Quelques commentaires :
\begin{itemize}
	\item \texttt{nb\%2} signifie \og le reste de la division par 2\fg. Si ce reste est bien égal à 0 c'est que la division par 2 tombe juste. Autrement dit, \texttt{nb} est pair;
	\item bien faire attention à l'utilisation du symbole \texttt{==} ligne 3 et du symbole \texttt{=} ligne 4 et 6 qui ont une signification totalement différente.
\end{itemize}
\end{cor}

\newpage
\begin{cor}[Python]
\begin{multicols}{2}
On dispose de deux variables \texttt{a} et \texttt{b}  qui contiennent chacune un nombre entier. Votre programme devra créer la variable \texttt{plusgrand} et lui affecter la plus grande valeur entre celle de \texttt{a} et celle de \texttt{b}. 
\columnbreak
\begin{lstlisting}
a = 5 #tester d'autres valeurs
b = 3 #tester d'autres valeurs 
if a>b :
	plusgrand = a
else :
	plusgrand = b
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}
Pourquoi pour la deuxième condition (ligne 5 du pseudo-code ou ligne 4 en Python), on ne vérifie pas que la moyenne est inférieure strictement à 10 ?\\
Cette ligne 5 (dans le pseudo-code) ou 4 (dans le code en Python) n'est lue que si la première condition \texttt{moyenne >= 10} n'est pas respectée. Autrement dit la moyenne est avec certitude inférieure strictement à 10.
\end{cor}

\begin{cor}[Python]
\begin{multicols}{2}
On dispose de la variable \texttt{moyenne} qui contient un nombre flottant. Votre programme devra créer la variable \texttt{decision} et lui affecter la valeur \texttt{"recalé(e)"} pour une moyenne inférieure strictement à 8,  \texttt{"rattrapage"} pour une moyenne supérieure à 8 et strictement inférieure à 10, \texttt{"admis(e)"} pour une moyenne supérieure à 10 et strictement inférieure à 12, \texttt{"mention assez bien"} pour une moyenne supérieure à 12 et strictement inférieure à 14, \texttt{"mention bien"} pour une moyenne supérieure à 14 et strictement inférieure à 16, et enfin, \texttt{"mention très bien"} pour une moyenne supérieure à 16. 
\columnbreak
\begin{lstlisting}
moyenne = 15.3 #tester d'autres valeurs
if moyenne < 8:
	decision = "recalé(e)"
elif < 10 :
	decision = "rattrapage"
elif < 12 :
	decision = "admis(e)"
elif < 14 :
	decision = "mention assez bien"
elif < 16 :
	decision = "mention bien"
else :
	decision = "mention très bien"
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}[Python (*)]
\begin{multicols}{2}
On dispose de la variable \texttt{mois} qui contient un nombre entier entre 1 et 12 représentant le mois de l'année (par exemple 5 pour le mois de mai).\\
Votre programme devra créer la variable \texttt{saison} et lui affecter la valeur \texttt{"printemps"}, \texttt{"été"}, \texttt{"automne"} et \texttt{"hiver"} correspondant à la saison.\\
\columnbreak
\begin{lstlisting}
mois = 5 #tester d'autres valeurs
if 3<= mois <= 5:
	saison = "printemps"
elif 6<= mois <= 8:
	saison = "été"
elif 9<= mois <= 11:
	saison = "automne"
else :
	saison = "hiver"
\end{lstlisting}
\end{multicols}
\begin{rem}
Dans la plupart des langages la condition de la ligne 2 s'écrirait \texttt{(mois >= 3) and (mois <=5)}. Il s'agit à nouveau d'une petite \textbf{pythonnerie} bien pratique qui nous permet de contracter ces deux conditions en un encadrement, comme on le fait naturellement en mathématiques.   
\end{rem}
\end{cor}

\newpage
\begin{cor}[Python (**)]
On dispose de la variable \texttt{annee} qui contient un nombre entier représentant l'année (par exemple 2020 pour cette année).\\
Votre programme devra créer la variable booléenne \texttt{bissextile} et lui affecter la valeur \texttt{True} ou \texttt{False} pour savoir si on pourra fêter l'anniversaire de Superman\footnote{\url{https://blog.francetvinfo.fr/case-a-part/2013/04/11/les-10-secrets-de-superman.html}}.\begin{lstlisting}
annee = 2020 #tester d'autres valeurs
if (annee%4 == 0) and ((annee%100 != 0) or (annee%400 ==0)) :
	bissextile = True
else :
	bissextile = False
\end{lstlisting}
On aurait aussi pu imaginer le code suivant, moins synthétique mais peut-être plus clair :
\begin{lstlisting}
annee = 2020 #tester d'autres valeurs
if annee%4 == 0 :
	if annee%100 != 0 :
		bissextile = True
	elif annee%400 ==0 :
		bissextile = True
	else :
		bissextile = False
\end{lstlisting}
\begin{rem}
Une année est bissextile si elle un multiple de 4 sauf pour les multiples de 100 sauf pour les multiples de 400...\\
Un exemple, l'année 2000 est un multiple de 4 donc ce devrait être une année bissextile, mais comme c'est aussi un multiple de 100 ce n'est pas plus année bissextile, mais comme il s'agit tout de même d'un multiple de de 400 l'année redevient un multiple de 400.\\
Pour plus d'information sur le sujet :\\
\url{https://fr.wikipedia.org/wiki/Année_bissextile}
\end{rem}
\end{cor}




\subsection{La structure répétitive \textbf{POUR}}
\begin{cor}[Python]
Écrire un programme qui affiche la table de multiplication par 3. On utilisera la fonction \texttt{print("un joli message")} qui affiche les chaînes de caractères.
\begin{lstlisting}
for i in range(1,11) :
	print("3 fois "+str(i)+" égale "+str(3*i))
\end{lstlisting}
\end{cor}


\begin{cor}[Python (*)]
\begin{multicols}{2}
Écrire un programme qui affiche tous les nombres multiple de 13 compris entre 0 et 666. On utilisera à nouveau la fonction \texttt{print(i)} qui affiche aussi le contenu d'une variable.\\ \\
\columnbreak
\begin{lstlisting}
for i in range(0,667) :
	if i%13 == 0 :
		print(i)
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}[Python (**)]
\begin{multicols}{2}
Écrire un programme qui affiche tous les nombres cubiques de 3 chiffres. Un nombre est dit cubique s'il est égal à la somme des cubes de ses chiffres.\\
Par exemple, 153 est un nombre cubique de 3 chiffres car :
\begin{itemize}
	\item il est composé de 3 chiffres
	\item $153 = 1^3 + 5^3 + 3^3$
\end{itemize}
On pourra utiliser les variables suivantes \texttt{c} le chiffre des centaines, \texttt{d} le chiffre des dizaines et \texttt{u} le chiffre des unités.\\
\columnbreak
\begin{lstlisting}
for i in range(100, 1000):
	c = i//100
	d = i//10 - c*10
	u = i - c*100 - d*10
	if c**3 + d**3 + u**3 == i :
		print(i)
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}[Fonction \texttt{range()}]
Quelles sont les listes de nombres obtenues dans chacun des cas suivants :
\begin{enumerate}
	\item \texttt{range(5)} : 0, 1, 2, 3, 4
	\item \texttt{range(4,10)} : 4, 5, 6, 7, 8, 9
	\item \texttt{range(10,4)} : rien
	\item \texttt{range(4,10,2)} : 4, 6, 8
	\item \texttt{range(10,4,-1)} : 10, 9, 8, 7, 6, 5
\end{enumerate}
\end{cor}

\begin{cor}[The Residents - Commercial Album]
\begin{multicols}{2}
1. On suppose que l'on a deux variables \texttt{couplet} et \texttt{refrain} de type chaîne de caractères et une fonction \texttt{sing()} qui chante le texte écrit dans une chaîne de caractères.\\
Écrire un programme qui permet d'obtenir une chanson pop selon le constat de \texttt{The Residents}.
\columnbreak
\begin{lstlisting}
for i in range(3) :
	sing(couplet)
	sing(refrain)
\end{lstlisting}
\end{multicols}
\begin{multicols}{2}
2. La structure proposée par \texttt{The Residents} est plutôt simpliste\footnote{Et c'était le but!}. Une chanson pop a plutôt la structure suivante : \texttt{intro}, \texttt{couplet}, \texttt{refrain}, \texttt{couplet}, \texttt{refrain}, \texttt{pont}, \texttt{refrain}, \texttt{couplet}, \texttt{refrain}, \texttt{refrain}\footnote{Ce qui permet d'obtenir une chanson d'un peu plus de 4 min !!!!}.\\
Compléter le programme ci-contre : \\
\columnbreak
\begin{lstlisting}
sing(intro)
for i in range(4) :
	if i!=2 :
		sing(couplet)
	else :
		sing(pont)
	sing(refrain)
sing(refrain)
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}[Retour de l'exercice 13 (*)]
\begin{multicols}{2}
Écrire un programme qui affiche tous les nombres multiple de 13 compris entre 0 et 666. \\
\columnbreak
\begin{lstlisting}
for i in range(0,667,13) :
	print(i)
\end{lstlisting}
\end{multicols}
\end{cor}







\subsection{La structure répétitive \textbf{TANT QUE}}
\begin{cor}
Expliquer ce qui se passe dans les deux cas suivants :
\begin{multicols}{2}
\begin{lstlisting}
i = 1
while i<11:
	sing(str(i) + " km à pieds ça use, ça use") 
	sing(str(i) + " km à pieds ça use les souliers")
\end{lstlisting}
\columnbreak
Comme la variable \texttt{i} n'est pas modifiée, elle vaut toujours 1. La condition \texttt{i<11} est toujours vraie. Le programme bouclera indéfiniment.
\end{multicols}
\begin{multicols}{2}
\begin{lstlisting}
i = 1
while i<11:
	sing(str(i) + " km à pieds ça use, ça use") 
	sing(str(i) + " km à pieds ça use les souliers")
i = i + 1
\end{lstlisting}
\columnbreak
La modification de la variable \texttt{i}, ligne 5, ne s'effectue qu'une fois la boucle \textbf{TANT QUE} terminée. On peut le voir car il n'y a pas d'indentation et donc la ligne 5 ne fait pas partie du bloc. La variable \texttt{i} n'est donc pas modifiée dans le bloc, elle vaut toujours 1. La condition \texttt{i<11} est toujours vraie. Le programme bouclera indéfiniment (et la ligne 5 ne sera jamais lu).
\end{multicols}
\end{cor}

\begin{cor}[Kraftwerk - Music non stop]
\begin{multicols}{2}
Écrire le plus simplement possible un programme qui répète à la l'infini \texttt{music non stop}.\\
\columnbreak
\begin{lstlisting}
while True :
	sing("music non strop")
\end{lstlisting}
\end{multicols}
\end{cor}


\begin{cor}[Jeu de dé (**)]
\begin{multicols}{2}
1. Écrire un programme qui simule le lancer d'un dé, jusqu'à ce qu'on obtienne enfin un 6.\\
Les résultats de chaque lancer seront affichés avec la fonction \texttt{print()}.\\
\columnbreak
\begin{lstlisting}
from random import randint
de = 7 #où autre nombre différent de 6
while de != 6 :
	de = randint(1,6)
	print(de)
\end{lstlisting}
\end{multicols}
\begin{multicols}{2}
2. (*) Modifier le programme précédent pour afficher à la fin le nombre total de lancer nécessaire pour enfin obtenir un 6.\\
\columnbreak
\begin{lstlisting}
from random import randint
de = 7 #où autre nombre différent de 6
nb = 0
while de != 6 :
	de = randint(1,6)
	print(de)
	nb = nb + 1
print("Il y a eu " +str(nb)+ " lancers.")
\end{lstlisting}
\end{multicols}
\begin{multicols}{2}
3. (**) On décide de déterminer combien, en moyenne, il est nécessaire de lancer un dé pour obtenir un 6. On décide d'effectuer 10 fois des séries de lancers de dé jusqu'à obtenir 6, puis de calculer la moyenne des 10 nombre de lancers nécessaire.\\
Pour une plus grande clarté, nous n'afficherons plus les résultats des lancers du dé.\\
\columnbreak
\begin{lstlisting}
from random import randint
somme = 0
for i in range(10):
	de = 7 #où autre nombre différent de 6
	nb = 0
	while de != 6 :
		de = randint(1,6)
		nb = nb + 1
	print("Il y a eu ",nb," lancers.")
	somme = somme + nb
moyenne = somme / 10
print("La moyenne est de",moyenne,"lancers")
\end{lstlisting}
\end{multicols}
\end{cor}




\subsection{Les sous-programmes}
\begin{cor}[Retour sur l'exercice 12]
\begin{multicols}{2}
Écrire une fonction qui permet d'afficher la table de multiplication choisie.\\
\columnbreak
\begin{lstlisting}
def table_multi(nb) :
	'''
	entrée : nb est un nombre entier
	affiche la table de multiplication de nb de 1 à 10
	'''
	for i in range(1,11) :
		print(nb,"fois",i,"égale",nb*i)
\end{lstlisting}
\end{multicols}
\end{cor}
 
\begin{cor}[Retour sur l'exercice 13]
\begin{multicols}{2}
Écrire une fonction qui correspond à sa documentation.\\
\columnbreak
\begin{lstlisting}
def multi(nb,a,b) :
	'''
	entrées : nb, a, b sont des nombres entiers
	affiche la liste des multiples de nb compris entre a et b (inclus)
	'''
	for i in range(a,b+1) :
		if i%nb == 0 :
			print(i)
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}[1 2 3 BOUM! (*)]
\begin{multicols}{2}
La fonction \texttt{boum(max,div)} affiche la liste des nombres entiers de 1 jusqu'à \texttt{max} avec une légère modification. Tous les nombres divisibles par le nombre \texttt{div} sont à écarter de la liste et sont remplacer par la chaîne de caractères \texttt{"BOUM !"}.\\
Par exemple \texttt{boum(14,3)} affichera 1, 2, BOUM !, 4, 5, BOUM !, 7, 8, BOUM !, 10, 11, BOUM !, 13, 14.\\
\columnbreak
\begin{lstlisting}
def boum(max,div) :
	'''
	entrées : max, div sont des nombres entiers
	affiche la liste modifiée des nombres entre 1 et max (inclus)
	'''
	for i in range(1,max+1) :
		if i%div == 0 :
			print("BOUM !")
		else :
			print(i)
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}[1 2 3 BOUM! (***)]
\begin{multicols}{2}
La fonction \texttt{boum\_plus(max,div)} affiche la liste des nombres entiers de 1 jusqu'à \texttt{max} avec une légère modification. Tous les nombres divisibles par le nombre \texttt{div} sont à écarter de la liste, ainsi que les nombres qui contiennent la séquence de chiffres de \texttt{div} et sont remplacer par la chaîne de caractères \texttt{"BOUM !"}.\\
Par exemple \texttt{boum\_plus(14,3)} affichera 1, 2, BOUM !, 4, 5, BOUM !, 7, 8, BOUM !, 10, 11, BOUM !, BOUM !, 14.\\
(le nombre 13 n'est pas affiché car il contient le chiffre 3)\\
\columnbreak
\begin{lstlisting}
def boum_plus(max,div) :
	'''
	entrées : max, div sont des nombres entiers
	affiche la liste modifiée des nombres entre 1 et max (inclus)
	'''
	for i in range(1,max+1) :
		if (i%div == 0) or (str(div) in str(i)) :
			print("BOUM !")
		else :
			print(i)
\end{lstlisting}
\end{multicols}
\end{cor}

\begin{cor}[Retour sur l'exercice 20 (**)]
\begin{multicols}{2}
La théorie probabiliste nous apprend qu'en \textbf{moyenne} il faut lancer 6 fois un dé pour enfin obtenir le nombre 6. A l'exercice 20, nous n'avons la moyenne que sur 10 lancers ce qui nous donne des résultats très fluctuants.\\
Écrire une fonction \texttt{moyenne\_de(faces,series)} qui retourne sous la forme d'un flottant le nombre moyen de lancers nécessaire pour enfin obtenir le résultat \texttt{faces} pour un dé qui aurait \texttt{faces} faces sur un total de \texttt{series} séries de lancers.\\
Par exemple \texttt{moyenne\_de(30,1000)}  affichera le nombre moyen de lancers pour enfin obtenir 30 avec un dé à 30 faces sur un total de 1000 séries de lancers.\\
(Comme vous vous en doutez, ce nombre est en théorie égale à 30)\\
\columnbreak
\begin{lstlisting}
from random import randint

def moyenne_de(faces,series) :
	'''
	entrées : faces, series sont des nombres entiers
	sortie : un nombre flottant
	calcul la moyenne sur series séries de lancers jusqu'à obtenir le nombre faces
	'''
	somme = 0
	for i in range(series):
		essais = -1 #pour être égal à faces
		nb = 0
		while essais != faces :
			essais = randint(1,faces)
			nb = nb + 1
		somme = somme + nb
	moyenne = somme / series
	return moyenne
\end{lstlisting}
\end{multicols}
\end{cor}

